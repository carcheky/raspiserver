# Instrucciones para generación de código - MediaCheky lang-flags.bash
**FECHA:** 16 junio 2025

## REGLAS CRÍTICAS

### 1. CONTENEDORES
- NUNCA usar `sudo` en scripts de contenedor
- Usar `docker compose exec` NO `docker exec`
- Probar comandos antes: `docker compose exec sonarr bash -c "comando"`
- Validar sintaxis: `bash -n script.sh` ANTES de commits

### 2. COLA Y CRON AUTO-GESTIONADOS
- **queue_only mode**: DEBE configurar cron automáticamente
- **Colas vacías**: DEBE quitar cron automáticamente  
- **Comandos validados Sonarr**: `pkill -HUP crond` (NO killall, NO service)
- **Ubicaciones cron**: `/etc/cron.d/` → `/tmp/` → `$FLAGS_DIR/cron/`

### 3. ESTRUCTURA MODULAR
- Funciones pequeñas, una responsabilidad
- Logging con timestamps: `[$(date '+%Y-%m-%d %H:%M:%S')] [LEVEL] mensaje`
- Error handling explícito en cada función
- Paths absolutos siempre

### 4. SCRIPT INICIALIZACIÓN CONTENEDOR
- lang-flags.bash GENERA `/custom-cont-init.d/lang_flags-install_deps.sh`
- Script generado: instala dependencias + configura permisos cron
- Se ejecuta LO PRIMERO en main()
- `rm -f archivo` antes de `cat > archivo` para evitar permission denied

## PATRONES EXITOSOS

```bash
# Función de logging
log_with_level() {
    local level="$1" message="$2"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" | tee -a "${LOG_FILE:-/tmp/script.log}"
}

# Cron auto-gestionado
"queue_only")
    process_queue_files
    setup_queue_processor  # Auto-configura cron
    ;;

# Validación de comandos
if command -v crond >/dev/null; then
    pkill -HUP crond 2>/dev/null || true
fi
```

## ANTIPATRONES A EVITAR
- Heredocs sin cerrar correctamente
- Funciones gigantes multi-propósito  
- Variables globales sin inicializar
- Asumir comandos del host en contenedores
- **Detección de contenedor** explícita cuando sea necesario
- **Flags de seguridad** para operaciones destructivas
- **Validaciones de input** en todos los parámetros

##### 8. CONFIGURACIÓN AUTOMÁTICA DE CRON EN MODO QUEUE_ONLY (CRÍTICO)
- **PROBLEMA IDENTIFICADO 16/06/2025**: El script NO configuraba automáticamente el cron cuando se ejecutaba en modo "queue_only"
- **IMPACTO**: Las colas se llenaban pero nunca se procesaban automáticamente
- **CAUSA**: `setup_queue_processor()` solo se llamaba en modos "monitor" y "--setup-cron", NO en "queue_only"
- **SOLUCIÓN APLICADA**: Añadir `setup_queue_processor()` en el caso "queue_only" del switch principal
- **PATRÓN CORRECTO**: Cuando Sonarr/Radarr añaden archivos a la cola, DEBE configurarse automáticamente el cron
- **VALIDACIÓN**: Verificar que existe `/etc/cron.d/lang-flags-queue` después de añadir elementos a la cola

```bash
# PATRÓN CORRECTO - modo queue_only DEBE configurar cron
"queue_only")
    log_info "Modo solo cola - evento ya procesado"
    # Asegurar que el procesador de cola esté configurado
    setup_queue_processor
    ;;
```

##### 9. Detección proactiva de problemas de cron
- **Verificación obligatoria**: Siempre comprobar si el cron está activo después de añadir elementos
- **Comando de verificación**: `docker exec sonarr crontab -l | grep lang-flags`
- **Fallback automático**: Si cron falla, usar proceso background como respaldo
- **Monitoreo**: Logs deben mostrar si se configuró cron o fallback

##### 10. GENERACIÓN DE SCRIPTS DE INICIALIZACIÓN DE CONTENEDOR (CRÍTICO)
- **PROBLEMA**: Script lang-flags.bash no puede crear cron jobs por falta de permisos en /etc/cron.d/
- **SOLUCIÓN REQUERIDA**: El script lang-flags.bash DEBE generar script /custom-cont-init.d/lang_flags-install_deps.sh
- **FUNCIÓN DEL SCRIPT GENERADO**:
  - Ejecutarse automáticamente al inicio del contenedor
  - Instalar TODAS las dependencias (ImageMagick, ExifTool, jq, ffmpeg, curl, wget, bc)
  - Configurar permisos de /etc/cron.d/ para permitir escritura posterior
  - Configurar ImageMagick policy.xml si es necesario
  - Crear estructura completa de directorios (/flags/queue, /flags/cache, etc.)
- **FLUJO CORRECTO**:
  1. Contenedor inicia → Ejecuta script de inicialización → Configura permisos y dependencias
  2. Sonarr/Radarr ejecuta lang-flags.bash → Puede crear cron jobs sin problemas
  3. Cron jobs procesan colas automáticamente
- **VALIDACIÓN**: Verificar que existe /custom-cont-init.d/lang_flags-install_deps.sh después de ejecutar lang-flags.bash
- **DEBUG**: Añadir logs detallados en la función generate_container_init_script() para troubleshooting

##### 11. TESTING Y VALIDACIÓN DE COMANDOS EN CONTENEDORES (CRÍTICO)
- **REGLA DE ORO**: SIEMPRE probar comandos con `docker compose exec` antes de incluirlos en scripts
- **NUNCA asumir** que comandos del host funcionan igual en contenedores
- **PROCESO OBLIGATORIO**:
  1. Probar comando con `docker compose exec [servicio] bash -c "comando"`
  2. Verificar que funciona correctamente
  3. Solo entonces incluirlo en el script
- **EJEMPLO REAL ENCONTRADO**:
  - `service cron reload` → NO existe en contenedor Sonarr
  - `killall -HUP crond` → NO funciona en contenedor Sonarr
  - `pkill -HUP crond` → SÍ funciona en contenedor Sonarr
- **COMANDOS VALIDADOS PARA SONARR**:
  - Cron daemon: `busybox crond -f -S -l 5`
  - Recargar cron: `pkill -HUP crond`
  - Verificar cron: `ps aux | grep cron`
- **NOTA**: Usar `docker compose exec` no `docker exec` (diferencias en contexto)

#### Patrones de código exitosos identificados:

```bash
# Verificación de sintaxis antes de commits
bash -n script.sh || exit 1

# Función de logging estructurado con niveles
log_with_level() {
    local level="$1"
    local message="$2"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $message" | tee -a "${LOG_FILE:-/tmp/script.log}"
}

# Manejo seguro de directorios
create_directory_safe() {
    local dir="$1"
    if [[ -n "$dir" ]] && mkdir -p "$dir" 2>/dev/null; then
        chmod 755 "$dir" 2>/dev/null || true
        log_debug "Directorio creado: $dir"
        return 0
    else
        log_error "No se pudo crear directorio: $dir"
        return 1
    fi
}

# Cron con fallback
setup_queue_processor() {
    local cron_locations=(
        "/etc/cron.d"
        "/tmp" 
        "$FLAGS_DIR/cron"
    )
    
    local cron_file=""
    for location in "${cron_locations[@]}"; do
        if [[ -w "$location" ]] || create_directory_safe "$location"; then
            cron_file="$location/lang-flags-queue"
            break
        fi
    done
    
    if [[ -n "$cron_file" ]]; then
        # Configurar cron con heredoc bien formado
        cat > "$cron_file" << 'EOF'
# Script content here
EOF
    else
        # Fallback a proceso background
        start_background_processor
    fi
}

# Estructura modular principal
main() {
    # 1. Configuración inicial
    setup_logging
    setup_directories
    
    # 2. Parsear argumentos
    parse_arguments "$@"
    
    # 3. Verificaciones de entorno
    verify_environment
    
    # 4. Lógica principal
    execute_mode
    
    # 5. Limpieza
    cleanup
}
```

#### Configuraciones específicas del proyecto:

##### Variables de entorno críticas:
- `FLAGS_DIR`: Directorio base para flags y colas
- `METADATA_CACHE_DIR`: Cache de metadatos (no CACHE_DIR)
- `LOG_FILE`: Archivo de logs con timestamp
- `QUEUE_LOCK_FILE`: Control de concurrencia

##### Estructura de directorios estándar:
```
flags/
├── queue/
│   ├── radarr_queue.txt
│   └── sonarr_queue.txt
├── cron/
│   └── lang-flags-queue
├── logs/
│   └── lang-flags.log
└── cache/
    └── metadata/
```

##### Antipatrones identificados y corregidos:
- **Heredocs sin cerrar correctamente**: Siempre usar delimitadores claros
- **Funciones gigantes**: Romper en funciones más pequeñas y específicas
- **Manejo de errores ausente**: Cada operación crítica debe tener validación
- **Logging inconsistente**: Usar funciones de logging estandarizadas
- **Variables globales sin inicializar**: Definir valores por defecto siempre